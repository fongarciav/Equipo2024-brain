<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Dashboard</title>
    <link rel="stylesheet" href="dashboard.css" />
  </head>
  <body>
    <div class="container">
      <h1>Robot Autonomo de Laboratorio - BFMC</h1>

      <!-- Connection Panel -->
      <div class="connection-panel">
        <select id="uart-port-select">
          <option value="">Select Port...</option>
        </select>
        <button onclick="refreshPorts()">Refresh</button>
        <button onclick="connectUART()">Connect</button>
        <button onclick="disconnectUART()">Disconnect</button>
        <span style="font-size: 10px">
          <span
            class="connection-status disconnected"
            id="connection-status"
          ></span>
          <span id="connection-text">Disconnected</span>
        </span>
      </div>

      <!-- Status Panel -->
      <div class="status-panel">
        <div class="status-item">
          <span class="status-label">Mode</span>
          <div class="status-value" id="status-mode">--</div>
        </div>
        <div class="status-item">
          <span class="status-label">State</span>
          <div class="status-value" id="status-state">--</div>
        </div>
        <div class="status-item">
          <span class="status-label">Updated</span>
          <div class="status-value" id="status-time">--</div>
        </div>
      </div>

      <!-- Main Layout: Left Controls, Right Video -->
      <div class="main-layout">
        <!-- Left Panel: Controls -->
        <div class="left-panel">
          <!-- System Control -->
          <div class="section">
            <h2 class="section-title">System</h2>
            <div
              style="
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 8px;
                margin-bottom: 8px;
              "
            >
              <div
                class="toggle-label"
                style="flex-direction: column; text-align: center"
              >
                <span>Armed</span>
                <label class="toggle-switch" style="margin: 4px auto 0">
                  <input
                    type="checkbox"
                    id="arm-toggle"
                    onchange="toggleArm(this.checked)"
                  />
                  <span class="toggle-slider"></span>
                </label>
              </div>
              <div
                class="toggle-label"
                style="flex-direction: column; text-align: center"
              >
                <span>Auto Mode</span>
                <label class="toggle-switch" style="margin: 4px auto 0">
                  <input
                    type="checkbox"
                    id="mode-toggle"
                    onchange="toggleMode(this.checked)"
                  />
                  <span class="toggle-slider"></span>
                </label>
              </div>
            </div>
            <div
              style="
                display: flex;
                gap: 8px;
                margin-bottom: 8px;
                align-items: center;
                justify-content: center;
              "
            >
              <span style="font-size: 10px; font-weight: bold">Lights:</span>
              <label class="toggle-switch">
                <input
                  type="checkbox"
                  id="lights-toggle"
                  onchange="toggleLights(this.checked)"
                />
                <span class="toggle-slider"></span>
              </label>
              <span style="font-size: 10px">Manual</span>
              <label class="toggle-switch">
                <input
                  type="checkbox"
                  id="lights-auto-toggle"
                  onchange="toggleLightsAuto(this.checked)"
                />
                <span class="toggle-slider"></span>
              </label>
              <span style="font-size: 10px">Auto</span>
            </div>
            <button
              class="btn btn-warning"
              onclick="sendCommand('brake')"
              style="width: 100%; margin-top: 5px"
            >
              EMERGENCY BRAKE
            </button>
          </div>

          <!-- Motor Control -->
          <div class="section">
            <h2 class="section-title">Motor</h2>
            <div class="button-grid">
              <button class="btn btn-success" onclick="sendCommand('forward')">
                FWD
              </button>
              <button class="btn btn-danger" onclick="sendCommand('back')">
                BACK
              </button>
              <button
                class="btn btn-secondary"
                onclick="sendCommand('driveStop')"
              >
                STOP
              </button>
            </div>
            <div class="slider-container">
              <div class="slider-label">
                <span>Speed</span>
                <div style="display: flex; align-items: center; gap: 8px">
                  <button
                    class="btn btn-secondary"
                    onclick="setSpeed(220)"
                    style="padding: 2px 8px; font-size: 10px"
                  >
                    220
                  </button>
                  <button
                    class="btn btn-secondary"
                    onclick="setSpeed(225)"
                    style="padding: 2px 8px; font-size: 10px"
                  >
                    225
                  </button>
                  <button
                    class="btn btn-secondary"
                    onclick="setSpeed(230)"
                    style="padding: 2px 8px; font-size: 10px"
                  >
                    230
                  </button>
                  <button
                    class="btn btn-secondary"
                    onclick="setSpeed(235)"
                    style="padding: 2px 8px; font-size: 10px"
                  >
                    235
                  </button>
                  <span id="speed-value">|</span>
                  <button
                    class="btn btn-secondary"
                    onclick="adjustSpeed(-1)"
                    style="padding: 2px 8px; font-size: 10px"
                  >
                    -1
                  </button>

                  <button
                    class="btn btn-secondary"
                    onclick="adjustSpeed(1)"
                    style="padding: 2px 8px; font-size: 10px"
                  >
                    +1
                  </button>
                </div>
              </div>
              <input
                type="range"
                id="speed-slider"
                min="0"
                max="255"
                value="0"
                oninput="updateSpeed(this.value)"
              />
              <div class="value-display" id="speed-display">Stopped: 0</div>
            </div>
          </div>

          <!-- Steering Control -->
          <div class="section">
            <h2 class="section-title">Steering</h2>
            <div class="button-grid">
              <button class="btn btn-primary" onclick="sendCommand('left')">
                LEFT
              </button>
              <button
                class="btn btn-secondary"
                onclick="sendCommand('steerStop')"
              >
                CENTER
              </button>
              <button class="btn btn-primary" onclick="sendCommand('right')">
                RIGHT
              </button>
            </div>
            <div class="slider-container">
              <div class="slider-label">
                <span>Angle</span>
                <span id="steer-value">105Â°</span>
              </div>
              <input
                type="range"
                id="steer-slider"
                min="50"
                max="160"
                value="105"
                oninput="updateSteering(this.value)"
              />
              <div class="value-display" id="steer-display">Center: 105Â°</div>
            </div>
          </div>

          <!-- Auto-Pilot Section -->
          <div class="section">
            <h2 class="section-title">Auto-Pilot</h2>
            <div class="autopilot-controls">
              <div
                style="
                  background: #1a1a1a;
                  border-radius: 5px;
                  padding: 6px;
                  font-size: 10px;
                "
              >
                <div style="font-weight: bold; color: #fff; margin-bottom: 6px">
                  PID Parameters
                </div>
                <div
                  class="pid-grid"
                  style="
                    grid-template-columns: repeat(4, 1fr);
                    margin-bottom: 8px;
                  "
                >
                  <div class="pid-control">
                    <label
                      >Kp:
                      <span id="pid-kp-value" class="pid-value"
                        >0.8380</span
                      ></label
                    >
                    <input
                      type="range"
                      id="pid-kp-slider"
                      min="0"
                      max="1"
                      step="0.001"
                      value="0.8380"
                      oninput="updatePIDParameter('kp', this.value)"
                    />
                  </div>
                  <div class="pid-control">
                    <label
                      >Ki:
                      <span id="pid-ki-value" class="pid-value"
                        >0.0100</span
                      ></label
                    >
                    <input
                      type="range"
                      id="pid-ki-slider"
                      min="0"
                      max="0.5"
                      step="0.001"
                      value="0.0100"
                      oninput="updatePIDParameter('ki', this.value)"
                    />
                  </div>
                  <div class="pid-control">
                    <label
                      >Kd:
                      <span id="pid-kd-value" class="pid-value"
                        >0.4300</span
                      ></label
                    >
                    <input
                      type="range"
                      id="pid-kd-slider"
                      min="0"
                      max="0.5"
                      step="0.001"
                      value="0.4300"
                      oninput="updatePIDParameter('kd', this.value)"
                    />
                  </div>
                  <div class="pid-control">
                    <label
                      >Deadband:
                      <span id="pid-deadband-value" class="pid-value"
                        >3.0</span
                      ></label
                    >
                    <input
                      type="range"
                      id="pid-deadband-slider"
                      min="0"
                      max="10"
                      step="0.1"
                      value="3.0"
                      oninput="updatePIDParameter('deadband', this.value)"
                    />
                  </div>
                </div>

                <div style="font-weight: bold; color: #fff; margin-bottom: 6px">
                  Status
                </div>
                <div
                  style="
                    display: flex;
                    justify-content: space-between;
                    margin-bottom: 4px;
                  "
                >
                  <span style="color: #fff; font-weight: bold">Status:</span>
                  <span
                    id="autopilot-status"
                    style="color: #ffc107; font-weight: bold"
                    >Checking...</span
                  >
                </div>
                <div
                  style="
                    display: flex;
                    justify-content: space-between;
                    margin-bottom: 4px;
                  "
                >
                  <span style="color: #fff">Steer:</span>
                  <span id="autopilot-pid-angle" style="color: #fff">--</span>
                </div>
                <div
                  style="
                    display: flex;
                    justify-content: space-between;
                    margin-bottom: 4px;
                  "
                >
                  <span style="color: #fff">Servo:</span>
                  <span id="autopilot-servo-angle" style="color: #fff">--</span>
                </div>
                <div
                  style="
                    display: flex;
                    justify-content: space-between;
                    margin-bottom: 8px;
                  "
                >
                  <span style="color: #fff">Commands:</span>
                  <span id="autopilot-command-count" style="color: #fff"
                    >0</span
                  >
                </div>
                <div
                  style="
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    margin-bottom: 8px;
                  "
                >
                  <label style="color: #fff; cursor: pointer; display: flex; align-items: center; gap: 6px;">
                    <input type="checkbox" id="lane-use-memory-checkbox" checked onchange="updateLaneUseMemory(this.checked)" />
                    Usar memoria (fallback)
                  </label>
                  <span id="lane-use-memory-hint" style="font-size: 10px; color: #888;">Desmarca = solo detecciÃ³n en vivo</span>
                </div>

                <div
                  style="
                    display: grid;
                    grid-template-columns: 1fr 1fr;
                    gap: 4px;
                  "
                >
                  <button
                    class="btn btn-success"
                    onclick="startAutopilot()"
                    style="font-size: 10px; padding: 4px"
                  >
                    START
                  </button>
                  <button
                    class="btn btn-danger"
                    onclick="event.stopPropagation(); stopAutopilot();"
                    style="font-size: 10px; padding: 4px"
                  >
                    STOP
                  </button>
                </div>
              </div>
            </div>
          </div>

          <!-- Sign Detection Section -->
          <div class="section">
            <h2 class="section-title">Sign Detection</h2>
            <div class="autopilot-controls">
              <div
                style="
                  background: #1a1a1a;
                  border-radius: 5px;
                  padding: 6px;
                  font-size: 10px;
                "
              >
                <div style="font-weight: bold; color: #fff; margin-bottom: 6px">
                  Detection Settings
                </div>
                <div class="pid-control" style="margin-bottom: 8px">
                  <label
                    >Confidence:
                    <span id="sign-confidence-value" class="pid-value"
                      >0.60</span
                    ></label
                  >
                  <input
                    type="range"
                    id="sign-confidence-slider"
                    min="0"
                    max="1"
                    step="0.01"
                    value="0.60"
                    oninput="updateSignConfidence(this.value)"
                  />
                </div>

                <div style="font-weight: bold; color: #fff; margin-bottom: 6px">
                  Status
                </div>
                <div
                  style="
                    display: flex;
                    justify-content: space-between;
                    margin-bottom: 4px;
                  "
                >
                  <span style="color: #fff; font-weight: bold">Status:</span>
                  <span
                    id="sign-detection-status"
                    style="color: #ffc107; font-weight: bold"
                    >Checking...</span
                  >
                </div>
                <div
                  style="
                    display: flex;
                    justify-content: space-between;
                    margin-bottom: 4px;
                  "
                >
                  <span style="color: #fff">Detections:</span>
                  <span id="sign-detection-count" style="color: #fff">0</span>
                </div>
                <div
                  style="
                    display: flex;
                    justify-content: space-between;
                    margin-bottom: 4px;
                  "
                >
                  <span style="color: #fff">Device:</span>
                  <span id="sign-device" style="color: #fff">--</span>
                </div>
                <div
                  style="
                    display: flex;
                    justify-content: space-between;
                    margin-bottom: 8px;
                  "
                >
                  <span style="color: #fff">Commands:</span>
                  <span id="sign-command-count" style="color: #fff">0</span>
                </div>

                <div
                  style="
                    display: grid;
                    grid-template-columns: 1fr 1fr;
                    gap: 4px;
                  "
                >
                  <button
                    class="btn btn-success"
                    onclick="startSignDetection()"
                    style="font-size: 10px; padding: 4px"
                  >
                    START
                  </button>
                  <button
                    class="btn btn-danger"
                    onclick="event.stopPropagation(); stopSignDetection();"
                    style="font-size: 10px; padding: 4px"
                  >
                    STOP
                  </button>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Right Panel: Video Feeds -->
        <div class="right-panel">
          <!-- Camera View Header -->
          <div
            style="
              display: flex;
              justify-content: space-between;
              align-items: center;
              flex-shrink: 0;
              margin-bottom: 8px;
            "
          >
            <h2 class="section-title" style="margin: 0">Camera Views</h2>
          </div>

          <!-- Debug Views (Always visible) -->
          <div
            class="section"
            id="debug-views-section"
            style="
              flex: 1;
              display: flex;
              flex-direction: column;
              min-height: 0;
            "
          >
            <div
              style="
                display: grid;
                grid-template-columns: repeat(2, 1fr);
                grid-template-rows: repeat(2, 1fr);
                gap: 8px;
                flex: 1;
                min-height: 0;
              "
            >
              <div class="video-container">
                <img src="/debug/bird_view_lines" alt="Bird View" />
                <div class="video-label">Bird View</div>
              </div>
              <div class="video-container">
                <img src="/debug/sliding_windows" alt="Sliding Windows" />
                <div class="video-label">Sliding Windows</div>
              </div>
              <div class="video-container">
                <img src="/debug/final_result" alt="Final Result" />
                <div class="video-label">Final Result</div>
              </div>
              <div class="video-container">
                <img src="/debug/sign_detections" alt="Sign Detections" />
                <div class="video-label">Sign Detections</div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Event Log (Collapsible) -->
      <div class="log-section">
        <div class="log-toggle" onclick="toggleLogs()">
          <span>ðŸ“‹ Event Log</span>
          <button
            class="btn btn-secondary"
            onclick="event.stopPropagation(); clearLogs()"
            style="padding: 3px 8px; font-size: 10px"
          >
            Clear
          </button>
        </div>
        <div class="log-panel" id="log-panel">
          <div class="log-entry info">
            Dashboard ready. Connect to ESP32 to start sending commands.
          </div>
        </div>
      </div>
    </div>

    <script>
      // Auto-detect server URL (same origin)
      let serverURL = window.location.origin;
      let isConnected = false;

      // Unified Event Stream Logic
      let eventSource = null;

      function initEventStream() {
        if (eventSource) {
          eventSource.close();
        }

        // Connect to the unified /events endpoint
        eventSource = new EventSource(`${getBaseURL()}/events`);

        eventSource.onmessage = function (event) {
          try {
            // Skip heartbeats
            if (event.data.includes(": heartbeat")) return;

            const data = JSON.parse(event.data);

            // Dispatch based on event type
            if (data.type === "serial") {
              handleSerialMessage(data);
            } else if (data.type === "server_log") {
              log(data.message, "info");
            } else if (data.type === "autopilot_status") {
              updateAutopilotStatusUI(data);
            } else if (data.type === "sign_detection_status") {
              updateSignDetectionStatusUI(data);
            }
          } catch (error) {
            // Fallback for raw serial messages (backward compatibility)
            if (!event.data.startsWith("{")) {
              // handleSerialMessage({message: event.data});
            }
          }
        };

        eventSource.onerror = function (error) {
          console.error("Event stream SSE error:", error);
          // Retry connection after delay
          setTimeout(() => {
            if (eventSource && eventSource.readyState === EventSource.CLOSED) {
              initEventStream();
            }
          }, 3000);
        };
      }

      function handleSerialMessage(data) {
        const message = data.message;

        if (message && message.trim().length > 0) {
          log(`ESP32: ${message}`, "serial");

          const servoCenter = 105;
          const servoRight = 50;
          const angleMax = 30;
          const speedUiMax = 255;
          const speedMmMax = 500;

          function mapSpeedMmToUi(speedMm) {
            const magnitude = Math.min(Math.abs(speedMm), speedMmMax);
            return Math.round((magnitude / speedMmMax) * speedUiMax);
          }

          function mapSteerTenthsToServo(steerTenths) {
            const conversionFactor = (servoCenter - servoRight) / angleMax;
            const steeringAngle = steerTenths / 10;
            const servoAngle = Math.round(servoCenter - (steeringAngle * conversionFactor));
            return Math.max(50, Math.min(160, servoAngle));
          }

          // Parse system events and update status in real-time
          if (message.startsWith("EVENT:STATE_CHANGED:")) {
            const state = message.replace("EVENT:STATE_CHANGED:", "").trim();
            updateStatusDisplay(state, null);
          } else if (message.startsWith("EVENT:MODE_CHANGED:")) {
            const mode = message.replace("EVENT:MODE_CHANGED:", "").trim();
            updateStatusDisplay(null, mode);
          } else if (message.startsWith("EVENT:CMD_EXECUTED:SET_SPEED:")) {
            // Update speed slider and display
            const speedStr = message
              .replace("EVENT:CMD_EXECUTED:SET_SPEED:", "")
              .trim();
            const speed = parseInt(speedStr);
            if (!isNaN(speed)) {
              const speedSlider = document.getElementById("speed-slider");
              const speedValue = document.getElementById("speed-value");
              const speedDisplay = document.getElementById("speed-display");

              if (speedSlider && speedValue && speedDisplay) {
                speedSlider.value = speed;
                speedValue.textContent = speed;
                speedDisplay.textContent =
                  speed === 0 ? "Stopped: 0" : `Speed: ${speed}`;
              }
            }
          } else if (message.startsWith("@speed:")) {
            const speedStr = message.replace("@speed:", "").replace(";;", "").trim();
            const speedMm = parseInt(speedStr);
            if (!isNaN(speedMm)) {
              const speedSlider = document.getElementById("speed-slider");
              const speedValue = document.getElementById("speed-value");
              const speedDisplay = document.getElementById("speed-display");
              const uiSpeed = mapSpeedMmToUi(speedMm);

              if (speedSlider && speedValue && speedDisplay) {
                speedSlider.value = uiSpeed;
                speedValue.textContent = uiSpeed;
                speedDisplay.textContent =
                  speedMm === 0
                    ? "Stopped: 0"
                    : `Speed: ${speedMm} mm/s`;
              }
            }
          } else if (message.startsWith("EVENT:CMD_EXECUTED:SET_STEER:")) {
            // Update steering slider and display
            const angleStr = message
              .replace("EVENT:CMD_EXECUTED:SET_STEER:", "")
              .trim();
            const angle = parseInt(angleStr);
            if (!isNaN(angle)) {
              const steerSlider = document.getElementById("steer-slider");
              const steerValue = document.getElementById("steer-value");
              const steerDisplay = document.getElementById("steer-display");

              if (steerSlider && steerValue && steerDisplay) {
                steerSlider.value = angle;
                steerValue.textContent = `${angle}Â°`;

                const center = 105;
                // NOTE: Servo is inverted - 50 = right, 160 = left
                if (angle === center) {
                  steerDisplay.textContent = "Center: 105Â°";
                } else if (angle < center) {
                  // Lower value (50) = right turn
                  steerDisplay.textContent = `Right: ${angle}Â°`;
                } else {
                  // Higher value (160) = left turn
                  steerDisplay.textContent = `Left: ${angle}Â°`;
                }
              }
            }
          } else if (message.startsWith("@steer:")) {
            const steerStr = message.replace("@steer:", "").replace(";;", "").trim();
            const steerTenths = parseInt(steerStr);
            if (!isNaN(steerTenths)) {
              const steerSlider = document.getElementById("steer-slider");
              const steerValue = document.getElementById("steer-value");
              const steerDisplay = document.getElementById("steer-display");
              const angle = mapSteerTenthsToServo(steerTenths);

              if (steerSlider && steerValue && steerDisplay) {
                steerSlider.value = angle;
                steerValue.textContent = `${angle}Â°`;

                const center = 105;
                if (angle === center) {
                  steerDisplay.textContent = "Center: 105Â°";
                } else if (angle < center) {
                  steerDisplay.textContent = `Right: ${angle}Â°`;
                } else {
                  steerDisplay.textContent = `Left: ${angle}Â°`;
                }
              }
            }
          } else if (message === "EVENT:CMD_EXECUTED:SET_STEER_CENTER") {
            // Center steering
            const steerSlider = document.getElementById("steer-slider");
            const steerValue = document.getElementById("steer-value");
            const steerDisplay = document.getElementById("steer-display");

            if (steerSlider && steerValue && steerDisplay) {
              const center = 105;
              steerSlider.value = center;
              steerValue.textContent = `${center}Â°`;
              steerDisplay.textContent = "Center: 105Â°";
            }
          }
        }
      }

      function startSerialStream() {
        // Legacy wrapper: Ensure event stream is running
        if (!eventSource || eventSource.readyState === EventSource.CLOSED) {
          initEventStream();
        }
        log("Serial stream monitoring started", "info");
      }

      function stopSerialStream() {
        // We don't stop the unified stream, just log
        log("Serial monitoring stopped", "info");
      }

      async function restoreSystemStatus() {
        // Get state from server (source of truth)
        // The server maintains the current state from ESP32
        try {
          const statusResponse = await fetch(`${getBaseURL()}/status`, {
            cache: "no-cache",
          });
          if (statusResponse.ok) {
            const statusData = await statusResponse.json();
            // Update display with server state
            updateStatusDisplay(
              statusData.state || null,
              statusData.mode || null
            );
            return;
          }
        } catch (error) {
          // If server is not available, show "--" (honest state)
          console.log("[restoreSystemStatus] Server unavailable");
        }

        // If server unavailable, show default/unknown state
        document.getElementById("status-mode").textContent = "--";
        const modeToggle = document.getElementById("mode-toggle");
        if (modeToggle) modeToggle.checked = false;

        const stateEl = document.getElementById("status-state");
        stateEl.textContent = "--";
        stateEl.className = "status-value";
        const armToggle = document.getElementById("arm-toggle");
        if (armToggle) armToggle.checked = false;
      }

      function restoreSliderValues() {
        // Slider values are restored from server events, no localStorage needed
      }

      function getBaseURL() {
        return serverURL;
      }

      function log(message, type = "info") {
        const logPanel = document.getElementById("log-panel");
        const entry = document.createElement("div");
        entry.className = `log-entry ${type}`;
        const timestamp = new Date().toLocaleTimeString();
        entry.textContent = `[${timestamp}] ${message}`;
        logPanel.appendChild(entry);
        logPanel.scrollTop = logPanel.scrollHeight;
      }

      function clearLogs() {
        const logPanel = document.getElementById("log-panel");
        logPanel.innerHTML = '<div class="log-entry info">Logs cleared.</div>';
      }

      function updateConnectionStatus(connected) {
        isConnected = connected;
        const statusEl = document.getElementById("connection-status");
        const textEl = document.getElementById("connection-text");

        if (connected) {
          statusEl.className = "connection-status connected";
          textEl.textContent = "Connected";
        } else {
          statusEl.className = "connection-status disconnected";
          textEl.textContent = "Disconnected";
        }
      }

      async function sendCommand(endpoint) {
        if (!isConnected) {
          log("UART not connected. Please connect first.", "error");
          return;
        }

        const url = `${getBaseURL()}/${endpoint}`;
        log(`Sending: ${endpoint}`, "info");

        try {
          const response = await fetch(url, {
            method: "GET",
            cache: "no-cache",
          });

          if (response.ok) {
            const data = await response.json();
            const uartCmd = data.uart_command
              ? ` â†’ UART: ${data.uart_command}`
              : "";
            log(`Command sent: ${endpoint}${uartCmd}`, "success");
          } else {
            const errorData = await response
              .json()
              .catch(() => ({ error: "Unknown error" }));
            log(
              `Error: ${endpoint} - ${errorData.error || response.status}`,
              "error"
            );
          }
        } catch (error) {
          log(`Failed to send: ${endpoint} - ${error.message}`, "error");
        }
      }

      function updateStatusDisplay(state, mode) {
        // Update state if provided
        if (state !== null) {
          document.getElementById("status-state").textContent = state;
          const stateEl = document.getElementById("status-state");
          stateEl.className = "status-value " + state.toLowerCase();
          // Update arm toggle based on state
          const armToggle = document.getElementById("arm-toggle");
          if (armToggle) {
            armToggle.checked = state === "ARMED" || state === "RUNNING";
          }
        }

        // Update mode if provided
        if (mode !== null) {
          document.getElementById("status-mode").textContent = mode;
          // Update mode toggle
          const modeToggle = document.getElementById("mode-toggle");
          if (modeToggle) {
            modeToggle.checked = mode === "AUTO";
          }
        }

        // Always update timestamp when status changes
        document.getElementById("status-time").textContent =
          new Date().toLocaleTimeString();
      }

      async function updateStatusInitial() {
        // Only used once on initial connection to get current state
        // After that, all updates come from events
        if (!isConnected) {
          document.getElementById("status-mode").textContent = "--";
          document.getElementById("status-state").textContent = "--";
          document.getElementById("status-state").className = "status-value";
          document.getElementById("status-time").textContent = "--";
          return;
        }

        try {
          // Get initial system status (mode and state) - only once on connect
          const statusResponse = await fetch(`${getBaseURL()}/status`, {
            cache: "no-cache",
          });
          if (statusResponse.ok) {
            const statusData = await statusResponse.json();
            updateStatusDisplay(
              statusData.state || null,
              statusData.mode || null
            );
          }
        } catch (error) {
          // Silently fail - status update is not critical
        }
      }

      async function refreshPorts() {
        try {
          log("Refreshing serial ports...", "info");
          const url = `${getBaseURL()}/uart/ports`;
          log(`Requesting: ${url}`, "info");

          const response = await fetch(url, {
            method: "GET",
            cache: "no-cache",
            headers: {
              Accept: "application/json",
            },
          });

          log(
            `Response status: ${response.status} ${response.statusText}`,
            "info"
          );

          if (response.ok) {
            const data = await response.json();
            log(`Received data: ${JSON.stringify(data)}`, "info");

            const select = document.getElementById("uart-port-select");
            select.innerHTML = '<option value="">Select UART Port...</option>';

            if (
              data.ports &&
              Array.isArray(data.ports) &&
              data.ports.length > 0
            ) {
              data.ports.forEach((port) => {
                const option = document.createElement("option");
                option.value = port.device;
                const desc = port.description || "No description";
                option.textContent = `${port.device} - ${desc}`;
                select.appendChild(option);
              });
              log(`Found ${data.ports.length} serial port(s)`, "success");
              // After ports are loaded, check if we're already connected and select the port
              checkInitialConnectionStatus();
            } else {
              log(
                `No serial ports found (count: ${
                  data.count || 0
                }). Make sure your ESP32 is connected.`,
                "error"
              );
              const option = document.createElement("option");
              option.value = "";
              option.textContent = "No ports available";
              option.disabled = true;
              select.appendChild(option);
            }
          } else {
            const errorText = await response.text();
            log(
              `Failed to get ports: ${response.status} - ${errorText}`,
              "error"
            );
            try {
              const errorData = JSON.parse(errorText);
              log(`Error details: ${JSON.stringify(errorData)}`, "error");
            } catch (e) {
              // Not JSON, already logged as text
            }
          }
        } catch (error) {
          log(`Failed to refresh ports: ${error.message}`, "error");
          log(`Error type: ${error.name}`, "error");
          log("Make sure the server is running and accessible", "error");
          console.error("Full error:", error);
        }
      }

      async function connectUART() {
        const portSelect = document.getElementById("uart-port-select");
        const port = portSelect.value;

        if (!port) {
          log("Please select a UART port", "error");
          return;
        }

        log(`Connecting to UART port ${port} via ${serverURL}...`, "info");

        try {
          const response = await fetch(`${serverURL}/uart/connect`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ port: port }),
          });

          if (response.ok) {
            const data = await response.json();
            updateConnectionStatus(true);
            log(
              `Connected to ${data.port} at ${data.baudrate} baud`,
              "success"
            );

            // Start listening to serial messages from ESP32 (will update status via events)
            startSerialStream();

            // Get initial status once (after stream starts, events will handle updates)
            updateStatusInitial();
          } else {
            const errorData = await response.json();
            log(`Connection failed: ${errorData.error}`, "error");
          }
        } catch (error) {
          log(`Connection error: ${error.message}`, "error");
        }
      }

      async function disconnectUART() {
        try {
          const response = await fetch(`${getBaseURL()}/uart/disconnect`, {
            method: "POST",
          });

          if (response.ok) {
            updateConnectionStatus(false);
            log("Disconnected from UART", "info");

            // Stop serial stream
            stopSerialStream();

            // Reset status display to "--" when disconnected
            document.getElementById("status-mode").textContent = "--";
            document.getElementById("status-state").textContent = "--";
            document.getElementById("status-state").className = "status-value";
            document.getElementById("status-time").textContent = "--";
          }
        } catch (error) {
          log(`Disconnect error: ${error.message}`, "error");
        }
      }

      function updateSpeed(value) {
        // Update UI immediately for user feedback
        const speed = parseInt(value);
        const speedValue = document.getElementById("speed-value");
        const speedDisplay = document.getElementById("speed-display");

        if (speedValue) speedValue.textContent = speed;
        if (speedDisplay) {
          speedDisplay.textContent =
            speed === 0 ? "Stopped: 0" : `Speed: ${speed}`;
        }

        // Send command to ESP32
        if (speed === 0) {
          sendCommand("changeSpeed?speed=0&direction=forward");
        } else {
          // Send command with forward direction by default
          sendCommand(`changeSpeed?speed=${speed}&direction=forward`);
        }
        // Note: Slider value will be updated again when ESP32 confirms via EVENT:CMD_EXECUTED
      }

      function adjustSpeed(delta) {
        const speedSlider = document.getElementById("speed-slider");
        if (!speedSlider) return;

        let currentSpeed = parseInt(speedSlider.value);
        let newSpeed = currentSpeed + delta;

        // Clamp to valid range
        newSpeed = Math.max(0, Math.min(255, newSpeed));

        // Update slider (which will trigger updateSpeed)
        speedSlider.value = newSpeed;
        updateSpeed(newSpeed);
      }

      function setSpeed(val) {
        const speedSlider = document.getElementById("speed-slider");
        if (!speedSlider) return;
        
        // Clamp to valid range
        const newSpeed = Math.max(0, Math.min(255, parseInt(val)));
        
        speedSlider.value = newSpeed;
        updateSpeed(newSpeed);
      }

      function updateSteering(value) {
        // Update UI immediately for user feedback
        const angle = parseInt(value);
        const steerValue = document.getElementById("steer-value");
        const steerDisplay = document.getElementById("steer-display");

        if (steerValue) steerValue.textContent = `${angle}Â°`;
        if (steerDisplay) {
          const center = 105;
          // NOTE: Servo is inverted - 50 = right, 160 = left
          if (angle === center) {
            steerDisplay.textContent = "Center: 105Â°";
          } else if (angle < center) {
            // Lower value (50) = right turn
            steerDisplay.textContent = `Right: ${angle}Â°`;
          } else {
            // Higher value (160) = left turn
            steerDisplay.textContent = `Left: ${angle}Â°`;
          }
        }

        // Send command to ESP32
        sendCommand(`changeSteer?angle=${angle}`);
        // Note: Slider value will be updated again when ESP32 confirms via EVENT:CMD_EXECUTED
      }

      async function checkInitialConnectionStatus() {
        try {
          const response = await fetch(`${getBaseURL()}/health`, {
            cache: "no-cache",
          });
          if (response.ok) {
            const data = await response.json();
            if (data.uart_connected && data.uart_port) {
              updateConnectionStatus(true);
              // Select the connected port in the dropdown
              const portSelect = document.getElementById("uart-port-select");
              if (portSelect) {
                portSelect.value = data.uart_port;
              }
              log(
                `Already connected to serial port: ${data.uart_port}`,
                "success"
              );
              // Start listening to serial messages from ESP32 (will update status via events)
              startSerialStream();
              // Get initial status once (after stream starts, events will handle updates)
              updateStatusInitial();
            } else {
              updateConnectionStatus(false);
              // Show "--" when not connected
              document.getElementById("status-mode").textContent = "--";
              document.getElementById("status-state").textContent = "--";
              document.getElementById("status-state").className =
                "status-value";
              document.getElementById("status-time").textContent = "--";
            }
          }
        } catch (error) {
          // Silently fail - connection check is not critical
          updateConnectionStatus(false);
          // Show "--" on error
          document.getElementById("status-mode").textContent = "--";
          document.getElementById("status-state").textContent = "--";
          document.getElementById("status-state").className = "status-value";
          document.getElementById("status-time").textContent = "--";
        }
      }

      // Auto-pilot functions
      async function startAutopilot() {
        try {
          const response = await fetch(`${getBaseURL()}/autopilot/start`, {
            method: "POST",
          });

          if (response.ok) {
            const data = await response.json();
            log(`Auto-pilot started: ${data.message || "OK"}`, "success");
            // Status will be updated automatically via SSE stream
          } else {
            const errorData = await response
              .json()
              .catch(() => ({ error: "Unknown error" }));

            // Build error message with suggestions if available
            let errorMessage = `Failed to start auto-pilot: ${
              errorData.error || response.status
            }`;
            if (errorData.suggestions && errorData.suggestions.length > 0) {
              errorMessage +=
                "\nSuggestions: " + errorData.suggestions.join(", ");
            }

            log(errorMessage, "error");

            // Update status display to show error
            const statusEl = document.getElementById("autopilot-status");
            if (statusEl) {
              if (
                errorData.error &&
                errorData.error.includes("not initialized")
              ) {
                statusEl.textContent = "Not Initialized";
              } else {
                statusEl.textContent = "Error";
              }
              statusEl.style.color = "#dc3545";
            }
            // Status will be updated automatically via SSE stream
          }
        } catch (error) {
          log(`Error starting auto-pilot: ${error.message}`, "error");

          // Update status display to show error
          const statusEl = document.getElementById("autopilot-status");
          if (statusEl) {
            statusEl.textContent = "Error";
            statusEl.style.color = "#dc3545";
          }
        }
      }

      async function stopAutopilot() {
        console.log("[stopAutopilot] Called");
        try {
          console.log("[stopAutopilot] Sending POST to /autopilot/stop");
          const response = await fetch(`${getBaseURL()}/autopilot/stop`, {
            method: "POST",
          });
          console.log(
            "[stopAutopilot] Response:",
            response.status,
            response.statusText
          );

          if (response.ok) {
            const data = await response.json();
            log(`Auto-pilot stopped: ${data.message || "OK"}`, "success");
            // Status will be updated automatically via SSE stream
          } else {
            const errorData = await response
              .json()
              .catch(() => ({ error: "Unknown error" }));

            // Build error message with suggestions if available
            let errorMessage = `Failed to stop auto-pilot: ${
              errorData.error || response.status
            }`;
            if (errorData.suggestions && errorData.suggestions.length > 0) {
              errorMessage +=
                "\nSuggestions: " + errorData.suggestions.join(", ");
            }

            log(errorMessage, "error");

            // Update status display to show error
            const statusEl = document.getElementById("autopilot-status");
            if (statusEl) {
              if (response.status === 503) {
                statusEl.textContent = "Not Initialized";
                statusEl.style.color = "#ffc107";
              } else {
                statusEl.textContent = "Error";
                statusEl.style.color = "#dc3545";
              }
            }
            // Status will be updated automatically via SSE stream
          }
        } catch (error) {
          log(`Error stopping auto-pilot: ${error.message}`, "error");

          // Update status display to show error
          const statusEl = document.getElementById("autopilot-status");
          if (statusEl) {
            statusEl.textContent = "Error";
            statusEl.style.color = "#dc3545";
          }
        }
      }

      function updateAutopilotStatusUI(data) {
        // Handle error case
        if (data.error) {
          const statusEl = document.getElementById("autopilot-status");
          if (statusEl) {
            statusEl.textContent = "Not Initialized";
            statusEl.style.color = "#ffc107"; // Yellow/warning color
          }
          return;
        }

        const status = data.status || {};
        const pidParams = data.pid_parameters || {};

        // Update status display
        const statusEl = document.getElementById("autopilot-status");
        if (statusEl) {
          statusEl.textContent = status.is_running ? "Running" : "Stopped";
          statusEl.style.color = status.is_running ? "#28a745" : "#dc3545";
        }

        // Update steering angle
        const pidAngleEl = document.getElementById("autopilot-pid-angle");
        if (
          pidAngleEl &&
          status.last_steering_angle !== null &&
          status.last_steering_angle !== undefined
        ) {
          pidAngleEl.textContent = `${status.last_steering_angle.toFixed(2)}Â°`;
        } else if (pidAngleEl) {
          pidAngleEl.textContent = "--";
        }

        // Update servo angle
        const servoAngleEl = document.getElementById("autopilot-servo-angle");
        if (
          servoAngleEl &&
          status.last_servo_angle !== null &&
          status.last_servo_angle !== undefined
        ) {
          servoAngleEl.textContent = `${status.last_servo_angle}Â°`;
        } else if (servoAngleEl) {
          servoAngleEl.textContent = "--";
        }

        // Update command count
        const commandCountEl = document.getElementById(
          "autopilot-command-count"
        );
        if (
          commandCountEl &&
          status.command_count !== null &&
          status.command_count !== undefined
        ) {
          commandCountEl.textContent = status.command_count.toString();
        } else if (commandCountEl) {
          commandCountEl.textContent = "0";
        }

        // Update PID parameters if available
        if (pidParams && Object.keys(pidParams).length > 0) {
          updatePIDSliders(pidParams, false); // false = don't trigger update
        }

        // Update lane use-memory checkbox
        const useMemory = data.use_memory_fallback;
        if (useMemory !== undefined) {
          const cb = document.getElementById("lane-use-memory-checkbox");
          if (cb) cb.checked = !!useMemory;
        }
      }

      async function updateLaneUseMemory(enabled) {
        try {
          const response = await fetch(`${getBaseURL()}/api/lane/use-memory`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ enabled: !!enabled }),
          });
          if (response.ok) {
            log(enabled ? "Memoria (fallback) activada" : "Memoria desactivada â€” solo detecciÃ³n en vivo", "success");
          } else {
            const err = await response.json().catch(() => ({}));
            log("Error al cambiar memoria: " + (err.error || response.status), "error");
            const cb = document.getElementById("lane-use-memory-checkbox");
            if (cb) cb.checked = !enabled;
          }
        } catch (e) {
          log("Error al cambiar memoria: " + e.message, "error");
          const cb = document.getElementById("lane-use-memory-checkbox");
          if (cb) cb.checked = !enabled;
        }
      }

      // Initialize - set status to "--" initially (will be updated if connected)
      document.getElementById("status-mode").textContent = "--";
      document.getElementById("status-state").textContent = "--";
      document.getElementById("status-state").className = "status-value";
      document.getElementById("status-time").textContent = "--";

      // Initialize - restore slider values and system status from server
      restoreSliderValues();
      restoreSystemStatus();

      // PID parameter update functions
      let pidUpdateTimeout = null;

      async function updatePIDParameter(param, value) {
        // Update display immediately
        const valueEl = document.getElementById(`pid-${param}-value`);
        if (valueEl) {
          if (param === "deadband") {
            valueEl.textContent = parseFloat(value).toFixed(1);
          } else {
            valueEl.textContent = parseFloat(value).toFixed(4);
          }
        }

        // Debounce API calls - wait 300ms after last change
        clearTimeout(pidUpdateTimeout);
        pidUpdateTimeout = setTimeout(async () => {
          try {
            const updateData = {};
            updateData[param] = parseFloat(value);

            const response = await fetch(`${getBaseURL()}/autopilot/pid`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(updateData),
            });

            if (response.ok) {
              const data = await response.json();
              log(`PID ${param} updated to ${value}`, "success");
              // Update sliders with server response to ensure sync
              if (data.pid_parameters) {
                updatePIDSliders(data.pid_parameters, false); // false = don't trigger update
              }
            } else {
              const errorData = await response.json().catch(() => ({}));
              log(
                `Failed to update PID ${param}: ${
                  errorData.error || response.status
                }`,
                "error"
              );
            }
          } catch (error) {
            log(`Error updating PID ${param}: ${error.message}`, "error");
          }
        }, 300);
      }

      async function loadPIDParameters() {
        try {
          const response = await fetch(`${getBaseURL()}/autopilot/pid`, {
            method: "GET",
            headers: { "Content-Type": "application/json" },
          });

          if (response.ok) {
            const data = await response.json();
            updatePIDSliders(data);
            log("PID parameters loaded", "success");
          } else {
            const errorData = await response.json().catch(() => ({}));
            log(
              `Failed to load PID parameters: ${
                errorData.error || response.status
              }`,
              "error"
            );
          }
        } catch (error) {
          log(`Error loading PID parameters: ${error.message}`, "error");
        }
      }

      function updatePIDSliders(params, triggerUpdate = true) {
        // Update Kp
        if (params.kp !== undefined) {
          const kpSlider = document.getElementById("pid-kp-slider");
          const kpValue = document.getElementById("pid-kp-value");
          if (kpSlider && kpValue) {
            kpSlider.value = params.kp;
            kpValue.textContent = parseFloat(params.kp).toFixed(4);
          }
        }

        // Update Ki
        if (params.ki !== undefined) {
          const kiSlider = document.getElementById("pid-ki-slider");
          const kiValue = document.getElementById("pid-ki-value");
          if (kiSlider && kiValue) {
            kiSlider.value = params.ki;
            kiValue.textContent = parseFloat(params.ki).toFixed(4);
          }
        }

        // Update Kd
        if (params.kd !== undefined) {
          const kdSlider = document.getElementById("pid-kd-slider");
          const kdValue = document.getElementById("pid-kd-value");
          if (kdSlider && kdValue) {
            kdSlider.value = params.kd;
            kdValue.textContent = parseFloat(params.kd).toFixed(4);
          }
        }

        // Update Deadband
        if (params.deadband !== undefined) {
          const deadbandSlider = document.getElementById("pid-deadband-slider");
          const deadbandValue = document.getElementById("pid-deadband-value");
          if (deadbandSlider && deadbandValue) {
            deadbandSlider.value = params.deadband;
            deadbandValue.textContent = parseFloat(params.deadband).toFixed(1);
          }
        }
      }

      // Toggle functions for new UI
      function toggleArm(checked) {
        if (checked) {
          sendCommand("arm");
        } else {
          sendCommand("disarm");
        }
      }

      function toggleMode(checked) {
        if (checked) {
          sendCommand("mode?value=AUTO");
        } else {
          sendCommand("mode?value=MANUAL");
        }
      }

      function toggleLights(checked) {
        if (checked) {
          sendCommand("LightsOn");
          document.getElementById("lights-auto-toggle").checked = false;
        } else {
          sendCommand("LightsOff");
        }
      }

      function toggleLightsAuto(checked) {
        if (checked) {
          sendCommand("LightsAuto");
          document.getElementById("lights-toggle").checked = false;
        } else {
          sendCommand("LightsOff");
        }
      }

      function toggleLogs() {
        const logPanel = document.getElementById("log-panel");
        logPanel.classList.toggle("visible");
      }

      // Sign Detection functions
      let signDetectionPollTimer = null;
      function stopSignDetectionPolling() {
        if (signDetectionPollTimer) {
          clearInterval(signDetectionPollTimer);
          signDetectionPollTimer = null;
        }
      }
      async function pollSignDetectionStatus() {
        try {
          const r = await fetch(`${getBaseURL()}/health`);
          const data = await r.json();
          const sd = data.sign_detection_status;
          const statusEl = document.getElementById("sign-detection-status");
          if (sd && sd.initializing) {
            if (statusEl) { statusEl.textContent = "Initializing..."; statusEl.style.color = "#ffc107"; }
            return true;
          }
          stopSignDetectionPolling();
          if (sd && (sd.is_running !== undefined || sd.device !== undefined)) {
            updateSignDetectionStatusUI({ status: sd });
          } else if (statusEl) {
            statusEl.textContent = "Not Initialized";
            statusEl.style.color = "#ffc107";
          }
          return false;
        } catch (e) { stopSignDetectionPolling(); return false; }
      }
      async function startSignDetection() {
        try {
          const response = await fetch(`${getBaseURL()}/sign_detection/start`, {
            method: "POST",
          });

          const data = await response.json().catch(() => ({}));
          if (response.ok) {
            log(`Sign detection started: ${data.message || "OK"}`, "success");
            const statusEl = document.getElementById("sign-detection-status");
            if (statusEl) { statusEl.textContent = "Running"; statusEl.style.color = "#28a745"; }
          } else if (response.status === 202) {
            log(data.message || "Sign detection initializing (30-60s)...", "info");
            const statusEl = document.getElementById("sign-detection-status");
            if (statusEl) { statusEl.textContent = "Initializing..."; statusEl.style.color = "#ffc107"; }
            stopSignDetectionPolling();
            signDetectionPollTimer = setInterval(pollSignDetectionStatus, 3000);
            pollSignDetectionStatus();
          } else {
            const errorData = data && data.error ? data : { error: "Unknown error" };
            let errorMessage = `Failed to start sign detection: ${errorData.error || response.status}`;
            if (errorData.suggestions && errorData.suggestions.length > 0) {
              errorMessage += "\nSuggestions: " + errorData.suggestions.join(", ");
            }
            log(errorMessage, "error");
            const statusEl = document.getElementById("sign-detection-status");
            if (statusEl) {
              statusEl.textContent = (errorData.error && errorData.error.includes("not initialized")) ? "Not Initialized" : "Error";
              statusEl.style.color = "#dc3545";
            }
          }
        } catch (error) {
          log(`Error starting sign detection: ${error.message}`, "error");

          // Update status display to show error
          const statusEl = document.getElementById("sign-detection-status");
          if (statusEl) {
            statusEl.textContent = "Error";
            statusEl.style.color = "#dc3545";
          }
        }
      }

      async function stopSignDetection() {
        console.log("[stopSignDetection] Called");
        try {
          console.log(
            "[stopSignDetection] Sending POST to /sign_detection/stop"
          );
          const response = await fetch(`${getBaseURL()}/sign_detection/stop`, {
            method: "POST",
          });
          console.log(
            "[stopSignDetection] Response:",
            response.status,
            response.statusText
          );

          if (response.ok) {
            const data = await response.json();
            log(`Sign detection stopped: ${data.message || "OK"}`, "success");
            // Status will be updated automatically via SSE stream
          } else {
            const errorData = await response
              .json()
              .catch(() => ({ error: "Unknown error" }));

            // Build error message with suggestions if available
            let errorMessage = `Failed to stop sign detection: ${
              errorData.error || response.status
            }`;
            if (errorData.suggestions && errorData.suggestions.length > 0) {
              errorMessage +=
                "\nSuggestions: " + errorData.suggestions.join(", ");
            }

            log(errorMessage, "error");

            // Update status display to show error
            const statusEl = document.getElementById("sign-detection-status");
            if (statusEl) {
              if (response.status === 503) {
                statusEl.textContent = "Not Initialized";
                statusEl.style.color = "#ffc107";
              } else {
                statusEl.textContent = "Error";
                statusEl.style.color = "#dc3545";
              }
            }
            // Status will be updated automatically via SSE stream
          }
        } catch (error) {
          log(`Error stopping sign detection: ${error.message}`, "error");

          // Update status display to show error
          const statusEl = document.getElementById("sign-detection-status");
          if (statusEl) {
            statusEl.textContent = "Error";
            statusEl.style.color = "#dc3545";
          }
        }
      }

      function updateSignDetectionStatusUI(data) {
        if (data.error) {
          const statusEl = document.getElementById("sign-detection-status");
          if (statusEl) {
            statusEl.textContent = "Not Initialized";
            statusEl.style.color = "#ffc107";
          }
          return;
        }

        const status = data.status || {};
        const statusEl = document.getElementById("sign-detection-status");
        if (statusEl) {
          if (status.initializing) {
            statusEl.textContent = "Initializing...";
            statusEl.style.color = "#ffc107";
          } else {
            statusEl.textContent = status.is_running ? "Running" : "Stopped";
            statusEl.style.color = status.is_running ? "#28a745" : "#dc3545";
          }
        }

        // Update detection count
        const detectionCountEl = document.getElementById(
          "sign-detection-count"
        );
        if (detectionCountEl) {
          detectionCountEl.textContent = status.current_detections || 0;
        }

        // Update device
        const deviceEl = document.getElementById("sign-device");
        if (deviceEl) {
          deviceEl.textContent = status.device || "--";
        }

        // Update command count
        const commandCountEl = document.getElementById("sign-command-count");
        if (commandCountEl) {
          commandCountEl.textContent =
            status.command_count !== undefined ? status.command_count : 0;
        }

        // Update confidence threshold display
        if (status.confidence_threshold !== undefined) {
          const confidenceValueEl = document.getElementById(
            "sign-confidence-value"
          );
          const confidenceSliderEl = document.getElementById(
            "sign-confidence-slider"
          );
          if (confidenceValueEl) {
            confidenceValueEl.textContent = parseFloat(
              status.confidence_threshold
            ).toFixed(2);
          }
          if (confidenceSliderEl) {
            confidenceSliderEl.value = status.confidence_threshold;
          }
        }
      }

      let signConfidenceUpdateTimeout = null;

      async function updateSignConfidence(value) {
        // Update display immediately
        const valueEl = document.getElementById("sign-confidence-value");
        if (valueEl) {
          valueEl.textContent = parseFloat(value).toFixed(2);
        }

        // Debounce API calls - wait 300ms after last change
        clearTimeout(signConfidenceUpdateTimeout);
        signConfidenceUpdateTimeout = setTimeout(async () => {
          try {
            const response = await fetch(
              `${getBaseURL()}/sign_detection/confidence`,
              {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ threshold: parseFloat(value) }),
              }
            );

            if (response.ok) {
              const data = await response.json();
              log(`Sign detection confidence updated to ${value}`, "success");
            } else {
              const errorData = await response.json().catch(() => ({}));
              log(
                `Failed to update confidence: ${
                  errorData.error || response.status
                }`,
                "error"
              );
            }
          } catch (error) {
            log(`Error updating confidence: ${error.message}`, "error");
          }
        }, 300);
      }

      // Initialize unified event stream
      initEventStream();

      // Load PID parameters on page load
      loadPIDParameters();

      // Initialize - refresh ports on load (connection status will be checked after ports load)
      log("Dashboard initialized. Select UART port and click Connect.", "info");
      refreshPorts();
    </script>
  </body>
</html>
